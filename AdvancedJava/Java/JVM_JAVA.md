# JVN & JAVA

---

### **JVM**이란
- JVM은 Java Virtual Machine의 약자로, 자바 가상머신이라고 부른다.
- 일종의 추상화된 컴퓨터
- JVM은 자바와 운영체제 사이에서 중개자 역할을 수행하며, 자바가 운영체제에 구애받지 않고 프로그램을 실행할 수 있도록 해준다
  - 자바코드는 운영체제에 독립적으로 작성할 수 있다
    - "Write Once, Run Anywhere"라는 자바의 철학을 가능하게 하는 것
  - .java -> .class -> (JVM) -> (운영체제)실행 의 구조를 가지므로 운영체제에 맞는 JVM만 있으면 자바 코드는 어디서든 동작할 수 있다
  - 자바코드는 운영체제에 종속적이지 않지만 JVM은 운영체제에 종속적이다
- 또한, 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하며, 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작한다
- JVM은 .java코드를 실행해주는 것이 아닌 .java파일이 javac compiler에 의해 바이트 코드로 변환된 .class파일을 실행한다
  - 이때 바이트코드를 인터프리트한다

### **JVM 메모리 구조**
- JVM의 구조는 크게 Garbage Collector, Execution Engine, Class Loader, Runtime Data Area로 나뉜다
1. Class Loader(클래스 로더)
   - JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
   - 런타임시에 동적으로 클래스를 로드
   - JVM 메모리에 해당 클래스에 대한 java.lang.Class 클래스의 인스턴스를 생성
   - JVM은 로딩, 연결, 초기화의 역할을 수행
   - 로딩(Loading): 클래스 로더는 .class 파일을 바이트 코드로 읽고, JVM 메모리의 메서드 영역에 해당 정보를 저장
   - 이 정보에는 클래스 레벨의 데이터(예: static 변수)가 포함

   - 연결(Linking): 연결은 검증, 준비, (선택적으로)해석이라는 세 단계로 이루어짐

    1. 검증(Verification): 바이트 코드가 올바른지 확인. 올바르지 않은 경우 VerifyError가 발생
    2. 준비(Preparation): 클래스 변수를 위한 메모리를 할당하고, 해당 변수에 기본 값들을 할당
    3. 해석(Resolution): 심볼릭 메모리 참조를 메서드 영역의 직접 참조로 변경. 
    4. 초기화(Initialization): static 변수에 정의된 값들이 할당되고, static 블록이 실행됩니다.

    - JVM은 기본적으로 세 가지 내장 클래스 로더를 가지고 있음
    1. 부트스트랩 클래스 로더(Bootstrap ClassLoader): JVM의 시작 시점에 로딩되며, JVM의 기본 클래스를 로드(JDK의 lib 폴더 내의 rt.jar 등).
    2. 확장 클래스 로더(Extension ClassLoader): 확장 디렉토리(jre/lib/ext 또는 java.ext.dirs 시스템 속성에 지정된 디렉토리)에 있는 클래스를 로드.
    3. 시스템 클래스 로더(Application ClassLoader): 환경 변수나 java -classpath 옵션으로 지정된 경로에 있는 클래스를 로드

    - java.lang.ClassLoader 클래스를 상속받아 사용자 정의 클래스 로더를 만들 수도 있음 
    - 이를 통해 동적 클래스 로딩, 원격 클래스 로딩, 암호화된 클래스 로딩 등의 복잡한 시나리오를 처리할 수 있음
2. Execution Engine(실행 엔진)
    - 클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어서 실행(인터프리트)
      - 최초 JVM은 인터프리터 방식이었지만 JIT(Just In TIME)컴파일러 방식을 통해 보완
        - JIT는 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿈
        - 하지만 런타임중 컴파일을 하는 방식이기 때문에 실행이 빠르지만 변환하는데 비용이 발생함
        - 따라서 JVM은 모든 코드를 JIT컴파일러 방식으로 실행하지 않고, 인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT컴파일러 방식으로 실행함
          - 인터프리터가 반복해서 읽어야 하는 코드들을 미리 컴파일해서 저장해 놓는 개념
    - 이 외에도 실행 엔진은 네이티브 메소드 인터페이스(Java Native Interface, JNI)를 통해 네이티브 메소드 라이브러리를 호출할 수 있음 
    - 이를 통해 자바 애플리케이션은 C, C++, 어셈블리어 등 다른 언어로 작성된 함수를 호출하고 사용할 수 있음
3. Garbage Collector(가비지 컬렉터)
    - 가비지 컬렉터는 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할을 함
    - GC가 역할을 하는 시간은 정확히 알 수 없음
4. Runtime Data Area(런타임 데이터 영역) - JVM의 메모리
    - JVM의 메모리 영역으로 자바 애플리케이션을 샐행할 때 사용되는 데이터들을 적재하는 영역
    - 크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack으로 나눌 수 있음
    1. Method Area
        - 모든 쓰레드가 공유하는 메모리 영역.
        - 메소드 영역은 클래스, 인터페이스, 메소드, 필드, Static변수, 생성자, 런타임 상수 풀 등의 바이트 코드를 보관
        - 클래스 수준의 정보를 저장
    2. Heap Area
        - 모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역
        - 메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거
    3. Stack Area
        - 각 쓰레드마다 하나씩 존재
        - 메서드 호출 시마다 각각의 스택 프레임(호출된 메서드만을 위한 공간)을 생성
        - 그리고 메서드 안에서 사용되는 값들을 저장하고, 호출된 메서드의 매개변수, 지역변수, 리턴값 및 연산시 일어나는 값들을 임시로 저장
        - 메서드 수행이 끝나면 프레임별로 삭제
    4. PC Register
        - 쓰레드가 시작될 때 생성되며, 생성될 때마다 생성되는 공간으로 쓰레드마다 하나씩 존재
        - 쓰레드가 어떤 부분을 무슨 명령으로 실행할 지에 대한 기록을 하는 부분 
        - 현재 수행중인 JVM명령의 주소를 가짐
    5. Native Method Stack
        - 각 쓰레드마다 하나씩 존재
        - 네이티브 메소드 스택은 네이티브 메소드의 정보를 저장하는 공간
        - 네이티브 메소드는 자바 외의 언어, 주로 C나 C++로 작성된 코드를 말함

### **JDK & JRE**
- JDK는 자바 프로그램을 작성하고, JRE를 실행하는데 필요한 툴을 가지고있음
- 컴파일러(javac)와 자바 어플리케이션 런처등을 포함하고 있음
  - 자바 어플리케이션 런처는 JRE를 실행시키는데 필요한 클래스나, 메인 메서드를 로딩
- JDK가 JRE보다 큰 개념
  - JDK `>` JRE `>` JVM 이런식으로 가지고 있는것
- JRE와 개발에 필요한 툴을 제공

- JRE는 클래스 라이브러리, JVM, 여러 Supporting파일을 가지고 있음
  - util, lang패키지등
- Debuger, Compiler와 같은 개발 도구는 포함되어 있지 않음
- 즉, JRE는 소스코드를 읽기 위해, JDK는 소스코드를 작성하기 위한 것들이 포함되어 있는것
- javac로 컴파일하는것 -> JDK
- 컴파일된 코드를 읽는것 -> JRE