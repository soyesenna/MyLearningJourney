--- 
#### 동시성
- 동시에 실행되는 것처럼 보이는 것
- 싱글 코어에서 멀티 스레드를 동작시키기 위한 방식으로, 멀티 태스킹을 위해 여러 개의 스레드가 번갈아가면서 실행되는 성질을 말한다.
- 멀티 스레드로 동시성을 만족시킬 수 있는 것이지 동시성과 멀티 스레드는 연관이 없다. 반례로 코틀린은 싱글스레드에서 코루틴을 이용하여 동시성을 만족할 수 있다.
	- 코루틴(Coroutine)`: `싱글 스레드에서도 루틴(routine) 이라는 단위(맥락상 함수와 동일)로 루틴간 협력이 가능하며, 동시성 프로그래밍을 지원하고 비동기 처리를 쉽게 도와주는 개념을 말한다.


#### 병렬성
- 실제로 동시에 실행되는 것
- 멀티 코어에서 멀티 스레드를 동작시키는 방식으로, **한 개 이상의 스레드를 포함하는 각 코어들이 동시에 실행되는 성질**을 말한다.

#### 병렬 안전성
- 여러 스레드가 동시에 액세스하더라도 프로그램의 오류 없이 실행되는 것
- 즉, 동시성 이슈를 해결하고 일어나지 않는다면 Thread Safe 한 것

### 동시성 이슈
Java에서 동시성 문제는 여러 스레드가 동시에 데이터에 액세스하려고 할 때 발생. 
-  **Race Condition**: 두 개 이상의 스레드가 동시에 공유 데이터에 액세스하고 수정하려고 할 때 발생한다. 이로 인해 데이터는 예측할 수 없는 상태가 될 수 있음.
	- 예를 들어, 두 스레드가 동시에 같은 계좌에서 돈을 인출하려고 하는 상황을 생각해보세요. 각 스레드는 계좌의 잔액을 읽고, 인출 금액을 빼고, 결과를 다시 계좌에 쓰려고 합니다. 이 과정에서 한 스레드가 계좌의 잔액을 읽은 후, 다른 스레드가 잔액을 변경하면, 첫 번째 스레드가 읽은 잔액은 더 이상 유효하지 않게 됩니다. 이런 상황을 race condition이라고 합니다.
-  **Deadlock**: 두 개 이상의 스레드가 서로를 기다리는 상황으로, 이로 인해 스레드가 영원히 진행되지 않을 수 있음.
	- 예를 들어, 스레드 A가 자원 1을 보유하고 있고 자원 2를 기다리는 동안, 스레드 B는 자원 2를 보유하고 있고 자원 1을 기다리는 상황이 발생할 수 있습니다. 이런 상황에서는 두 스레드 모두 자신이 필요로 하는 자원을 얻지 못하고 영원히 대기 상태에 머무르게 됩니다.
-  **Starvation**: 특정 스레드가 자원에 대한 액세스를 영원히 얻지 못하고 대기 상태에 머무르는 상황. 이는 스케줄링 정책, 스레드 우선순위 등에 의해 발생할 수 있음.
	- 예를 들어, 우선순위가 높은 스레드가 계속 실행되면서 우선순위가 낮은 스레드가 실행되지 못하는 상황을 생각해보세요. 이런 상황에서 우선순위가 낮은 스레드는 자원에 대한 액세스를 얻지 못하고 영원히 대기 상태에 머무르게 됩니다.
-  **LiveLock**: 두 개 이상의 스레드가 서로를 기다리는 상황이지만, 상태를 변경하려는 시도는 계속되는 상황. 이는 Deadlock과 비슷하지만, 스레드는 진행 상태가 아니라 상태 변경을 시도하는 상태에 머무른다.
	- 예를 들어, 두 스레드가 서로를 기다리면서 계속해서 자신의 상태를 변경하려는 시도를 하는 상황을 생각해보세요. 이런 상황에서는 두 스레드 모두 진행되지 않고, 계속해서 자신의 상태를 변경하려는 시도만을 반복하게 됩니다.

### 자바의 동시성 이슈를 해결하기 위한 도구
- **Synchronized Blocks**: Java에서는 synchronized 키워드를 사용하여 특정 코드 블록에 대한 동시 액세스를 제한할 수 있음. 이는 공유 데이터에 대한 동시 수정을 방지하고, race condition을 방지하는 데 도움이 된다
- **Volatile Keyword**: volatile 키워드는 변수를 메인 메모리에 저장하도록 지시함. 이는 모든 스레드가 동일한 변수 값을 보게 하여, 변수 값의 불일치 문제를 방지하는 데 도움이 된다.
- **Atomic Classes**: Java는 원자성을 보장하는 클래스들을 제공함. 이 클래스들은 복합 연산도 원자적으로 수행할 수 있게 해서, race condition을 방지하는 데 도움이 됩니다. 예를 들어, AtomicInteger, AtomicLong 등이 있습니다.
-  **Locks**: Java는 java.util.concurrent.locks패키지에서 명시적 락을 제공합니다. 이 락들은 synchronized키워드보다 더 세밀한 제어를 가능하게 한다.
-  **ThreadLocal Class**: ThreadLocal클래스는 각 스레드에 대해 별도의 변수 복사본을 유지한다. 이는 공유 변수에 대한 동시 액세스를 방지하고, race condition을 방지하는 데 도우을 준다.
-  **Concurrent Collections**: Java는 동시 액세스를 지원하는 컬렉션 클래스들을 제공한다. 이 컬렉션들은 내부적으로 동기화되어 있어, 별도의 동기화 없이 안전하게 사용할 수 있다. ConcurrentHashMap등
- **Executors and Thread Pools**: java.util.concurrent 패키지는 스레드 풀과 executor 프레임워크를 제공한다.
- **Futures and Callables**: Future와 Callable인터페이스는 비동기 계산의 결과를 나타내고, 스레드가 계산을 완료하면 결과를 얻을 수 있다.
-  **Semaphores**: 세마포어는 한 번에 특정 수의 스레드만이 특정 자원에 액세스할 수 있도록 제한하는 데 사용된다
- **CountDownLatch and CyclicBarrier**: 이들은 스레드가 특정 지점에서 대기하도록 하여, 다른 스레드가 특정 작업을 완료할 때까지 기다리게 하는 데 사용.
