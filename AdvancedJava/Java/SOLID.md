--- 
- SOLID란?
	- 객체지향 프로그램을 개발할때 지켜할 5가지 원칙
	- 이런 디자인 패턴을 사용하면 좀 더 유지보수하기 쉽고, 유연하고, 확장이 쉬운 소프트웨를 만들 수 있다
	- 이 원리들은 패턴보다 크기가 작지만 표준화 작업부터 아키텍쳐 설계에까지 다양하게 적용된다
- SRP(Single Responsibility Principle)
	- 단일 책임 원칙
	- 하나의 클래스는 하나의 책임만 가진다
		- 즉 하나의 클래스는 하나의 기능만 가질 수 있다
		- 클래스를 변경해야 하는 이유가 단 하나뿐이어야 한다
	- SRP를 적용하면 책임 영역이 확실해지기 때문에 다른 책임의 변경으로인한 연쇄작용으로부터 자유로워질 수 있다
	- 책임을 적절히 분배함으로써 코드의 가독성이 높아지고 유지보수하기 쉬워진다
	- 다른 원칙들에 비해서 비교적 단순하지만 변경사항이 많은 실무에서는 이 원칙에 맞게 설계하기 쉽지 않다
		- 따라서 많은 연습과 경험이 필요하다
	- 예시(ChatGPT)
		- '사용자 관리'와 '사용자에게 이메일 보내기'라는 두 가지 책임을 가진 클래스를 생각해봅시다. 이 두 가지 기능은 각각 다른 이유로 변경될 수 있습니다. 사용자 관리 기능은 사용자 데이터의 저장 및 검색 로직이 변화할 때 수정이 필요하고, 이메일 보내기 기능은 이메일 서비스의 변경이나 이메일 형식의 변화로 인해 수정이 필요할 수 있습니다. 이런 상황에서 단일 책임 원칙을 지키지 않으면, 한 기능의 변경이 다른 기능에 영향을 줄 수 있어, 유지보수가 어려워질 수 있습니다.
		- 따라서, SRP에 따라 이 클래스를 두 개의 클래스로 분리해야 합니다: '사용자 관리' 클래스와 '사용자에게 이메일 보내기' 클래스. 이렇게 하면 각 클래스는 자신의 책임에만 집중할 수 있고, 한 기능의 변경이 다른 기능에 영향을 주지 않게 됩니다.
- OCP(Open Close Principle)
	- 개방 폐쇄의 원칙
	- 클래스는 확장에는 열려있고 변경에는 닫혀있어야 한다
		- 변경을 위한 비용은 최대한 줄이고 확장을 위한 비용은 극대화 시켜야 한다
	- 이 원칙의 핵심은 기존의 코드를 변경하지 않고도 시스템의 동작을 변경하거나 확장시킬 수 있어야 한다는 것
	- 이를 위해 추상화라는 개념을 사용한다
		- 그래디 부치(Grady Booch)에 의하면 ***추상화란 다른 모든 종류의 객체로부터 식별될 수 있는 객체의 본질적인 특징***이라고 정의하고 있다
		- 추상화를 통해 변경이 일어나는 부분을 캡슐화한다
		- 하지만 과도한 추상화는 추상화 과정하는 비용이 증가하게 하고 코드를 복잡하게 만들 수 있으므로 적절하게 사용해야한다
	- 요구사항의 변경이나 추가사항이 발생하더라도 기존 요소는 변경이 발생하지 말아야하며, 기존 구성 요소를 쉽게 확장할 수 있어야 한다
	- 변경이 될 것과 변경이 되지 않을 것을 엄격하게 구분한 후 두 모듈이 만나는 지점에 인터페이스를 정의한다
	- 구현에 의존하기보다 인터페이스에 의존하게 설계한다
		- 클라이언트가 인터페이스에 의존하므로 인터페이스는 가능하면 절대 변경하지 않도록 설계해야한다
	- 예시(ChatGPT)
		- 각기 다른 동물들의 집합을 처리하는 프로그램이 있다고 생각해봅시다. 각 동물은 "음식을 먹는다"라는 행동을 가지고 있습니다. 이 시스템에서 새로운 동물을 추가하려면 어떻게 해야 할까요? 개방-폐쇄 원칙을 따르지 않으면, 각 동물을 처리하는 코드를 변경하거나 추가해야 할 것입니다.
		- 그러나 OCP에 따르면, 우리는 "동물"이라는 추상 클래스를 만들고, "음식을 먹는다"라는 추상 메서드를 정의할 것입니다. 그리고 각 동물은 이 추상 클래스를 상속받아 "음식을 먹는다"라는 행동을 구현할 것입니다. 이렇게 하면 새로운 동물을 추가하려면 단순히 새 클래스를 생성하고 "음식을 먹는다"라는 행동을 구현하면 됩니다. 기존의 코드는 전혀 변경하지 않아도 됩니다.
- LSP(The Liskov Substitiution Principle)
	- 리스코프 치환의 원칙
	- 서브타입은 언제나 기반타입으로 교체될 수 있어야 한다
		- 즉 서브타입은 언제나 기반타입과 호환이 되어야 한다
	- 클라이언트가 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 대체하더라도 클라이언트코드의 정확성이 보장되어야 한다는 것
		- 즉 부모 클래스의 모든 기능이 자식 클래스에서도 작동해야한다
		- 자식 클래스는 부모 클래스의 모든 속성과 행동을 가지고 있어야 하며 이를 확장하거나 오버라이드 할 수 있지만 이를 손상시키거나 변경해서는 안된다
	- 예시(ChatGPT)
		- "사각형" 클래스가 "너비"와 "높이"를 가지고 있고, "넓이를 계산"하는 메서드가 있다고 가정합시다. 이제 "정사각형"이라는 클래스를 "사각형" 클래스의 서브클래스로 만들어 봅시다. "정사각형"은 "사각형"의 특별한 경우이므로 이 상속은 합리적으로 보일 수 있습니다. 그러나 "정사각형"은 너비와 높이가 항상 같아야 하므로, 너비와 높이를 독립적으로 설정하는 "사각형" 클래스의 행동을 변경하게 됩니다. 이 경우, "정사각형"은 LSP를 위반하게 됩니다. 사각형을 정사각형으로 대체하는 것이 클라이언트 코드를 손상시킬 수 있기 때문입니다.
- ISP(Interface Segregation Principle)
	- 인터페이스 분리의 원칙
	- 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다
		- 즉 어떤 클래스가 다른 클래스에 종속될 때는 가능한 최소한의 인터페이스를 사용해야 한다
	- 하나의 일반적인 인터페이스보다는 여러개의 구체적인 인터페이스가 낫다
	- 클라이언트는 필요한 메서드만을 가진 인터페이스에 의존해야 한다
		- 불필요한 의존성이 제거되고, 시스템간의 결합도가 줄어들며, 유지보수와 확장이 용이해진다
	- 예시
		- "프린터" 인터페이스가 "인쇄하기", "스캔하기", "팩스 보내기", "이메일 보내기" 네 가지 메서드를 가지고 있다고 생각해봅시다. 그런데 "간단한 프린터"라는 클래스는 "인쇄하기" 기능만 필요하다면, 이 클래스는 "스캔하기", "팩스 보내기", "이메일 보내기" 메서드에 대한 의존성이 생기게 됩니다. 이는 ISP를 위반하는 것입니다.
		- 따라서, 이 원칙에 따라 "프린터" 인터페이스를 "인쇄기", "스캐너", "팩스기", "이메일 발송기" 네 개의 인터페이스로 분리해야 합니다. 그리고 "간단한 프린터" 클래스는 "인쇄기" 인터페이스만을 구현하면 됩니다.
- DIP(Dependency Inversion Principle)
	- 의존관계 역전의 원칙
	- "고수준 모듈은 저수준 모듈에 의존하면 안 되며, 둘 다 추상화에 의존해야 한다"와 "추상화는 세부 사항에 의존하면 안 되며, 세부 사항이 추상화에 의존해야 한다"는 두 부분의 원칙을 포함한다
	- 이 원칙의 목표는 강력한 의존성 결합을 방지하고, 시스템의 유연성을 높이는 것이다
	- 예시
		- 응용 프로그램의 로직(고수준 모듈)이 데이터베이스에 직접적으로 의존(저수준 모듈)하는 경우를 생각해봅시다. 이 경우, 데이터베이스의 변경(예를 들어, MySQL에서 PostgreSQL로의 변경)은 응용 프로그램 로직에 큰 영향을 미칠 것입니다. 이는 유지보수를 어렵게 만들고, 테스트가 복잡해질 수 있습니다.
		- 이 문제를 해결하기 위해 DIP를 적용하면, 응용 프로그램 로직과 데이터베이스는 모두 추상화(예: 인터페이스나 추상 클래스)에 의존하게 됩니다. 이렇게 하면, 응용 프로그램 로직은 데이터베이스의 구체적인 세부 사항을 몰라도 됩니다. 데이터베이스를 변경해야 하는 경우, 새 데이터베이스가 동일한 추상화를 구현하도록 만들면 됩니다.

	



