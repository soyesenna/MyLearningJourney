# Serialization

- [x] 1. Serialization 정의
- [x] 2. Serialization 사용
- [x] 3. Serialization 장점과 단점

<br>
<br>

---

## 1. Serialization의 정의

---

<br>

 **Serialization**란 자바 언어에서 사용되는 Object 또는 Data를 다른 컴퓨터의 자바 시스템에서도 사용할 수 있도록, **바이트 스트림(stream of bytes) 형태로 연속적인 데이터로 변환하는 포맷 변환 기술**을 말한다. 그와 반대 개념으로 **Deserialization**이 존재하며, 바이트로 변환된 데이터를 원래대로 자바 시스템의 Object 또는 Data로 변환하는 기술이다. 즉 시스템적으로 JVM의 힙, 스택 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변화하여, 데이터베이스나 파일과 같은 외부 저장소, 어떤 곳에 저장을 해두고, 다른 컴퓨터에서 이 파일을 가져와 Deserialization을 통해 자바 객체로 변환해 사용이 가능하다.

<br>

## 2. Serialization의 사용

---

<br>

 **Serialization**는 Object 또는 Data를 어딘가에 저장해두고 다른 곳에서도 사용이 되게끔 할 수 있다. 이를 통해 우리는 객체를 저장하고, 전송하거나, 캐시처럼 이용이 가능하다는 뜻이 되기도 한다.

 직렬화를 응용한다면, 휘발성이 있는 캐싱 데이터를 영구 저장이 필요할 때 사용을 할 수 있다. 예를 들어, JVM의 메모리에 있는 데이터가 시스템이 끝나도, 값을 유지하고 재사용이 되게 끔하려면 객체의 상태를 어딘가에 저장해두고 다시 실행할 때, 불러오는 **영속화**를 해두면 된다.

 **세션** : 우리는 세션을 유지할 때, 하나의 서버안에서 모든게 이루어지면 굳이 필요로 하지 않지만, 로그인 서버, 웹페이지 1서버 등 다양한 서버가 존재할 때, 이사람이 로그인을 했는지 안했는지, 다른 서버와 데이터를 교환해야한다. 이 경우 객체를 직렬화하여 다른 서버와 객체를 공유하고 효율적으로 처리가 가능하다.

 **캐시** : 데이터베이스의 용량이 커질수록 값을 빈번하게 값을 가져오는 쿼리를 계속해서 수행할 경우 상당히 비효율적이다. 이 경우, 직렬화를 이용해 캐시를 저장하고 불러온다. 하지만, Redis와 같은 캐시 DB를 이용하는 추세이다.

 **RMI** : 자바 RMI는 원격 시스템 간의 메시지 교환을 위해서 사용하는 자바에서 지원하는 기술로, 이 메세지에 객체 데이터를 직렬화하여 송신한다.

<br><br>

## 3. Serialization의 장점과 단점

---

<br>

 그렇다면 Serialization은 유용하고 많이 사용되는 것일까? 답부터 말하자면 절대 아니다. 물론 구현은 상당히 간단하다. 하지만 자바뿐만이 아니라, 이를 집중적으로 관리하는 도구들이 생겨났기에 상황에 따라 잘 이용해야한다. 

 **CSV, JSON**, 데이터를 읽고 쓰는 데 사용되는 구조화된 데이터 형식으로 주로 텍스트 파일로 사용된다. 가장 큰 장점은 하나의 언어에 적용되는 것이 아닌 다양한 언어에 적용이 가능하며, CSV는 테이블 형태의 데이터를 다룰 때, JSON은 그것보다 더 복잡한 데이터의 계층 구조까지 표현이 가능하다. 하지만 자바의 객체 상태까지는 적용이 불가능하며, 직렬화는 데이터 구조와 필드를 직접적으로 노출하지 않는다.

 사실 직렬화는 쉬운 구현에 비해 상당한 대가를 치뤄야 한다. 직렬화의 경우 용량이 상당히 크다. 쉽게 비교하자면, JSON파일과 직렬화 파일의 크기 차이는 2배 이상 차이가 난다. 

 역직렬화는 위험하다. 역직렬화를 하는 과정에서 공격을 당할 위험성이 존재한다. 즉 직렬화가 가능한 클래스 들은 공격에 대비하여 작성을 해야하지만, 이 경우에도 여전히 취약하며, 가장 좋은 방법은 역직렬화를 하지 않는 것이다.

 직렬화를 구현하여, 출시를 했을 경우 직렬화의 구조의 수정이 상당히 어렵다. 즉 하나의 API가 되는 셈인데, 이 경우 직렬화의 형태를 달리할 경우 문제가 발생한다.

 클래스의 캡슐화가 깨진다. 직렬화할 클래스에 private로 선언한 멤버가 있어도 직렬화를 하게 되면 노출이 된다. 이 경우 trasient를 이용해 직렬화 대상에서 제외하는 번거로운 과정을 거쳐야 한다.


<br><br>

