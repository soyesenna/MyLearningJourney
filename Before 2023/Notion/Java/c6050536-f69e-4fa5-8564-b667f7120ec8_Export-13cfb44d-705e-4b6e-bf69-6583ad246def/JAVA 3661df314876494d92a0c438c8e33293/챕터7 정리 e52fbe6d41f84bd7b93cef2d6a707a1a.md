# 챕터7 정리

---

- 상속
    - 상속이란 새로운 클래스를 작성할때 다른 클래스를 이용하는 것을 의미한다
    - 키워드 extends를 사용하며 상속해주는 클래스를 조상클래스, 상속 받는 클래스를 부모클래스라고 한다
    
    ```java
    class Tv{
        boolean power;
        int channel;
    
        void power(){
            power = !power;
        }
        void channelUp(){
            ++channel;
        }
        void channelDown(){
            --channel;
        }
    }
    
    //Tv클래스를 상속받음
    class SmartTv extends Tv{
        boolean caption;
        void displayCaption(String str){
            if(caption){
                System.out.println(caption);
            }
        }
    }
    ```
    
    - 상속을 받는 자손클래스는 부모클래스의 모든 멤버를 상속받는다
        - 자손클래스는 부모클래스가 가지고 있는 멤버도 가지고 있다고 간주하는것
        - 자손클래스의 인스턴스를 생성하면 부모클래스의 멤버와 자손클래스의 멤버가 합쳐진 인스턴스가 생성됨
    - 여러 클래스들간의 공통된 부분을 부모클래스로 떼어서 상속받게하면 그 공통된 부분에서 수정이 발생해도 부모클래스만 변경하면 자손클래스들은 모두 변경한 상태로 됨
        - 관리 용이
        - 코드 중복제거
    - 따라서 자손클래스는 항상 부모클래스보다 같거나 많은 멤버를 가지고 있음
        - 부모의 모든 멤버를 상속받기때문에 자식멤버개수 :  부모멤머 + a(자기멤버)
        - 이는 클래스를 확장한다고도 볼 수 있으므로 키워드 extends를 사용
    - 자바는 여러개의 부모로부터 상속을 받는 다중상속을 허용하지 않는다
        - 하나의 조상으로부터만 상속을 받는 단일상속만을 허용한다
            1. 다중상속의 경우 상속계층도가 매우 복잡해질 가능성이 있고
            2. 만약 여러 부모클래스들에 선언부가 같은 인스턴스 메서드가 있을때 상속을 받는 자식클래스에서 어떤 메서드를 사용해야할지 불명확해진다
    - 모든 클래스의 최고 부모 클래스는 Object클래스이다
        - 다른 클래스로부터 상속을 받지 않는 클래스는 컴파일러가 자동으로 extends Object를 추가해줌으로써 항상 상속계층도 맨 위에 Object클래스가 존재하도록 만든다

---

- 포함
    - 포함이란 클래스내에 다른 클래스의 참조변수를 멤버변수로 선언하는것을 의미
    - 즉 한 클래스에서 다른 클래스의 참조변수를 멤버변수로 이용하여 사용하므로 상속받는게 아닌 사용하는 클래스에 다른 클래스가 포함되어 있다고함
    - 클래스들을 여러개의 단위로 나누어 작성한다음 포함관계로 재사용하면 손쉽게 클래스를 작성할 수 있고 직관적으로 보기 쉬워짐
    
    ```java
    class Point{
        int x;
        int y;
    
        Point(){}
        Point(int x, int y){
            this.x = x;
            this.y = y;
        }
    }
    
    class Circle{
        Point p;
        int r;
    
        Circle(){
            this(new Point(0, 0), 1);
        }
        Circle(Point p, int r){
            this.p = p;
            this.r = r;
        }
    }
    ```
    
    - 위 코드에서 Point클래스를 Circle클래스가 포함하고 있음

---

- 클래스간의 관계 결정하기
    - 상속관계와 포함관계를 결정하는 확실한 방법은 없음
    - 하지만 is a 와 has a 문장을 만들어보면 보다 명확해짐
        - Circle은 Point이다(is a) → 상속
        - Circle은 Point를 가지고 있다(has a) → 포함
        - 이 경우 has a 관계가 더 매끄러우므로 포함관계로 설정하는 것이 바람직하다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled.png)
    

---

- 오버라이딩
    - 오버라이딩이란 부모 클래스로부터 상속받은 메서드를 자식메서드에 맞게 변경하는 것을 의미한다
    - 오버라이딩은 메서드의 내용만을 변경하는것이므로 선언부는 부모의 것과 완전히 일치해야한다
        - 이름, 반환타입, 매개변수타입과 개수
    - 오버라이딩한 자식 메서드의 접근제어자는 부모의 것보다 범위가 넓거나 같아야한다
    - 조상클래스의 메서드보다 많은수의 예외를 선언할 수 없다
    - 인스턴스메서드 ↔ 스태틱메서드간의 변경을 허용하지 않는다
        - static메서드는 오버라이딩이 허용되지만 오버라이딩이라기보단 다른 클래스에 각각 정의된 static메서드라고 보는 편이 옳다
            - static메서드는 클래스이름.메서드이름으로 항상 호출할 수 있기때문에 구별되기 때문이다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%201.png)
    
    ```java
    class Point{
        int x;
        int y;
    
        Point(){}
        Point(int x, int y){
            this.x = x;
            this.y = y;
        }
        String getLocation(){
            return "x : " + x  + ", y : " + y;
        }
    }
    
    class Point3D extends Point{
        int z;
        Point3D(){}
        Point3D(int x, int y, int z){
            this.x = x;
            this.y = y;
            this.z = z;
        }
        String getLocation(){   //오버라이딩
            return "x : " + x  + ", y : " + y + ", z : " + z;
        }
    }
    ```
    

---

- super참조변수
    - super참조변수는 상속해준 부모클래스의 주소가 저장되어있는 변수이다
    - 부모로부터 상속받은 멤버변수의 이름과 자식의 멤버변수의 이름이 같은경우 사용한다
    
    ```java
    class Parent{
        int x = 10;
    }
    class Child extends Parent{
        int x = 20;
    
        void method(){
            System.out.println("super.x = " + super.x); //super.x = 10
            System.out.println("this.x = " + this.x);   //this.x = 20
        }
    }
    ```
    
    - 자식의 멤버변수는 this로 부모의 멤버변수는 super로 구별한다
    - 변수만이 아니라 메서드도 super를 써서 호출할 수 있다
        - 함수를 오버라이딩한경우 사용한다
    
    ```java
    class Point{
        int x;
        int y;
    
        Point(){}
        Point(int x, int y){
            this.x = x;
            this.y = y;
        }
        String getLocation(){
            return "x : " + x  + ", y : " + y;
        }
    }
    
    class Point3D extends Point{
        int z;
        Point3D(){}
        Point3D(int x, int y, int z){
            this.x = x;
            this.y = y;
            this.z = z;
        }
        String getLocation(){   //오버라이딩
            return super.getLocation() + ", z : " + z;  //부모의 메서드 호출
        }
    }
    ```
    

---

- 생성자 super()
    - 생성자 super()는 부모의 생성자를 호출하는데 사용된다
    - 자식클래스는 항상 부모의 모든 멤버를 포함하므로 항상 부모클래스의 인스턴스 초기화작업이 선행되어야한다
    - 자식클래스의 생성자 첫줄에는 반드시 this()또는 super()가 호출되어야한다
        - super()를 호출하는 이유는 자식클래스의 멤버가 부모클래스의 멤버를 사용할 수도 있으므로 항상 먼저 초기화가 되어있어야 한다
        - 이러한 생성자의 호출은 상속관계를 거슬러가며 계속되므로 최고부모인 Object클래스의 생성자를 만나야 끝이난다
        - 따라서 Object클래스를 제외한 모든 클래스는 첫 줄에 반드시 자신의 생성자(this)또는 부모의 생성자(super)를 호출해야한다
        - 호출하지않으면 컴파일러가 자동으로 super();를 호출한다
    - 자식클래스의 생성자의 첫줄에 생성자를 호출하지않으면 자동으로 super();를 컴파일러가 호출하므로 만약 부모클래스에 기본생성자가 존재하지 않는다면 오류가 발생한다
    - 따라서 부모클래스의 멤버변수는 부모클래스의 생성자에의해 초기화되도록 해야한다

---

- 패키지
    - 패키지는 클래스의 묶음이다
    - 패키지에는 클래스 또는 인터페이스를 포함시킬 수 있다
    - 클래스를 관련된 그룹단위로 묶어놓으므로써 효율적으로 관리할 수 있다
    - 클래스의 풀네임은 패키지명까지 포함한 것이다
        - PakageTest.class → com.codechobo.book.PakageTest.class
    - 클래스가 하나의 파일인것처럼 패키지는 하나의 디렉토리이다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%202.png)
    
    - 패키지는 pakage 패키지명;으로 선언한다

---

- impot문
    - 코드를 작성할때 다른 패키지의 클래스를 사용하려면 패키지의 이름까지 명시해주어야한다
    - 이는 매우 불편한 일이기때문에 코드 작성 전에 import문으로 사용하고자하는 클래스의 패키지 이름을 명시해주면 패키지 이름을 생략하고 클래스를 사용할 수 있다
    - import문은 패키지문 다음에 그리고 클래스 선언문 전에 위치한다
    - import문은 한 소스파일에 여러번 선언할 수 있다
    - 패키지명.* 을 사용하면 해당 패키지에 존재하는 모든 클래스들을 임포트할 수있다
    - 같은 패키지의 클래스들은 import없이 사용할 수 있다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%203.png)
    
    - static import문은 static맴버를 호출할때 클래스명을 생략할 수 있다
    
    ```java
    import static java.lang.Integer.*;
    
    System.out.println(parseInt("123")); //Integer.parseInt()에서 Integer생략
    ```
    

---

- 제어자
    - 제어자는 클래스, 변수 또는 메서드의 선언부에 함께사용되어 부가적인 의미를 부여한다
    - 접근제어자와 그 외 제어자로 나뉜다
    - 하나의 대상에 대해서 여러개의 제어자를 조합하여 사용할 수 있다
    - 접근제어자는 한번에 하나만 선택해서 사용할 수 있다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%204.png)
    
    - static
        - 클래스의, 공통적인
        - 멤버변수나 메서드 앞에 붙는다
        - 멤버변수 앞에 붙으면 인스턴스 변수와 달리 각각의 인스턴스에 관계없이 같은 값을 갖는다
        - 메서드 앞에 붙으면 인스턴스 생성없이 호출이 가능하다
            - 인스턴스 메서드와 static메서드의 근본적인 차이는 인스턴스 변수의 사용여부이다
            - 메서드가 인스턴스 변수를 사용하지 않는다면 static으로 선언하는것을 고려해야한다
    - final
        - 마지막의, 변경될 수 없는
        - 변수, 메서드, 클래스에 사용된다
        - 변수에 사용되면 더이상 값을 변경할 수 없는 상수가 된다
            - final이 붙은 멤버변수는 생성자에의해 초기화 될 수 있다
        - 메서드에 사용되면 자식클래스에서 오버라이딩을 할 수 없게된다
        - 클래스에 사용되면 확장하지 못한다는 의미를 가지므로 다른 클래스의 부모가 될 수 없다
    - abstract
        - 추상의, 미완성의
        - 메서드와 클래스에 사용된다
        - 구현부({})를 작성하지 않고 선언부만 작성한 메서드 앞에 사용된다
        - 추상메서드를 포함한 클래스앞에 붙어서 추상클래스라는 것을 나타낸다
    - 접근 제어자
        - 멤버(생성자 포함) 또는 클래스에 사용되어 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한한다
        - 접근제어자가 지정돼있지 않다면 default이다
        1. private
            1. 같은 클래스 내에서만 접근이 가능하다
        2. default
            1. 같은 패키지 내에서만 접근이 가능하다
        3. protected
            1. 같은 패키지 + 다른 패키지의 자손클래스에서 사용 가능
        4. public
            1. 접근제한이 전혀 없음
        
        ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%205.png)
        
        - 클래스는 public, (default)만 사용가능
        - 메서드, 멤버변수는 전부 사용 가능

---

- 캡슐화
    - 접근제어자를 사용하여 클래스내부의 데이터를 보호한다
    - 데이터가 유효한 값을 갖도록, 또는 외부에서 함부로 변경하지 못하도록 하는 것이 캡슐화이다
    - 외부에는 불필요한, 내부작업에만 필요한 데이터를 감추기 위해서도 한도 한다
    
    ```java
    Time t = new Time();
    t.hour = 25; //시는 0~23사이의 값이지만 접근을 제한하지 않으면 외부에서의 변경을 막을 수 없다
    ```
    
    - 상속을 통해 확장될 가능성이 있는 클래스라면 멤버의 접근제한을 private이 아닌 protected로 해야 자손 클래스에서 멤버에 접근할 수 있다
        - private는 자손에서도 접근할 수 없다
    
    ```java
    public static void main(String[] args) {
            Time t = new Time();
            //t.hour = 25; //private멤버이므로 외부에서 직접 접근할 수 없다
            t.setHour(25);  //25는 범위 밖의 값이므로 변경되지 않는다
            System.out.println(t.getHour());    //기본 초기화값인 0 출력
        }
    
    class Time{
        private int hour;
        private int minute;
        private int second;
    
        Time(){}
        Time(int hour, int minute, int second){
            this.hour = hour;
            this.minute = minute;
            this.second = second;
        }
    
        public int getHour(){ return this.hour; }
        public int getMinute(){ return this.minute; }
        public int getSecond(){ return this.second; }
        public void setHour(int hour){
            if (isRightTime(hour, "hour")){
                this.hour = hour;
            }
        }
        public void setMinute(int minute){
            if (isRightTime(minute, "minute")) {
                this.minute = minute;
            }
        }
        public void setSecond(int second){
            if (isRightTime(second, "second")){
                this.second = second;
            }
        }
        private boolean isRightTime(int num, String option){
            if (option.equals("hour")){
                if (num < 0 || num > 23) return false;
                else return true;
            }else{
                if (num < 0 || num > 59) return false;
                else return true;
            }
        }
    }
    ```
    
    - 멤버변수는 private 또는 protected로 선언하여 외부에서의 접근을 막고 public메서드를 사용하여 유효성 여부나 비정상접근등을 확인한 후 멤버변수의 값을 바꾼다
    - get멤버변수이름 → 해당 멤버변수를 반환함
    - set멤버변수이름 → 해당 멤버변수를 변경함(유효성검사등등을 거친후)
    - 생성자의 접근제어자
        - 보통 생성자의 접근제어자는 클래스의 것과 같지만 다르게 할 수 있다
        - 생성자의 접근제어자를 private으로 할경우 외부에서 해당 클래스의 인스턴스를 생성할 수 없다
        - 따라서 클래스내부에서 멤버변수로 인스턴스를 미리 생성한 후 반환해주는 메서드를 만들어야한다
            - 외부에서 인스턴스 생성 여부와 관계없이 호출되어야하므로 static메서드로 만들어야하고 마찬가지로 인스턴스 참조변수는 static메서드에서 사용되어야하므로 static이어야한다
        - private생성자를 가진 클래스는 자식 클래스에서 해당 클래스의 생성자를 호출할 수 없으므로 상속을 할 수 없다
            - 따라서 final을 사용하여 더이상 상속할 수 없는 클래스라는 것을 명시해주는 것이 좋다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%206.png)
    

---

- 다형성
    - 객체지향개념에서 다형성이란 여러가지 형태를 가질 수 있는 능력을 의미
    - 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하는것
        - 부모클래스의 참조변수로 자식클래스의 객체를 참조할 수 있다
    - 부모클래스의 멤버는 항상 자손클래스의 멤버보다 같거나 적다
        - 자식클래스의 멤버는 항상 부모클래스의 멤버를 포함한다
    - 참조변수가 사용할 수 있는 멤버는 참조변수의 타입(클래스)의 멤버수에 따르므로 부모클래스의 참조변수로 사용할 수 있는 멤버는 항상 자식클래스의 객체에 존재한다
    - 따라서 부모클래스의 참조변수로 자식클래스 객체를 참조할 수 있다
        - 다만 부모클래스의 참조변수는 부모클래스에 정의된 멤버만 사용가능하기 때문에 자식클래스에서 확장된 멤버들은 사용이 불가능하다
    - 같은 타입의 인스턴스라도 참조변수의 종류에따라 사용할 수 있는 멤버가 달라진다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%207.png)
    
    - 같은 이치로 자식클래스의 참조변수로 부모타입의 객체를 참조할 수 없다
        - 자식클래스에는 부모클래스에 정의되지않은 멤버가 존재할 수 있으므로(확장한다, 상속의 의미) 자식클래스의 참조변수로 부모클래스 인스턴스를 참조하면 실제 인스턴스(부모객체)에 존재하지않는 멤버를 참조변수가 사용하려고 할 수 있다
    - 참조변수가 사용할 수 있는 멤버의 개수는 실제 인스턴스의 멤버개수보다 같거나 적거야한다
    - 다형성을 이용하면 부모클래스의 참조변수로 모든 자식클래스들의 객체를 받을수 있다

---

- 참조변수의 형변환
    - 참조변수의 형변환은 부모클래스타입의 참조변수와 자식클래스타입의 참조변수간에 가능하다
        - 자식↔부모 양방향의 변환이 가능하다
    - 자식클래스타입(이하 자식타입)에서 부모클래스타입(이하 부모타입)으로 형변환하는것은 참조변수가 사용할 수 있는 멤버의 개수를 줄이는 것이기때문에 항상 가능하다
    - 부모타입에서 자식타입으로 형변환하는것은 참조변수가 사용할 수 있는 멤버의 개수를 늘리는 것이기때문에 확인이 필요하다(instance of연산자로 확인)
    - 참조변수를 형변환할때는 변환하고자하는 참조변수가 실제로 가리키는 객체가 무엇인지를 먼저 확인하고 형변환하고자하는 타입(클래스)의 멤버가 실제 가리키는 객체의 멤버보다 많으면 안된다
    - 형변환은 참조변수의 타입을 변환하는것이지 인스턴스를 변환하는것은 아니기때문에 참조변수의 형변환은 실제 인스턴스에 아무런 영향도 미치지 못한다
        - 단지 형변환을 통해 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 개수를 조절하는것
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%208.png)
    

---

- instance of 연산자
    - 참조변수가 참조하고 있는 실제 인스턴스를 알아보기위해 사용
    - 연산자의 왼쪽에는 참조변수를 오른쪽에는 클래스이름(타입)을 적는다
    - instance of 연산자의 리턴타입은 boolean으로 리턴이 true이면 참조변수가 오른쪽의 클래스(타입)으로 형 변환이 가능하다는 뜻
        - 자식 참조변수에서 부모 참조변수로의 형변환은 언제든 가능하므로 자식참조변수 instead of 부모클래스 는 항상 true이다

---

- 참조변수와 인스턴스의 연결
    - 자식클래스와 부모클래스에서 중복정의된 멤버변수의 경우 참조변수의 타입(클래스)에 따라 호출되는 변수가 달라진다
        - 자식클래스타입인경우 자식클래스의 멤버변수가 사용되고 부모클래스타입인경우 부모클래스의 멤버변수가 사용된다
        - 메서드는 항상 실제 인스턴스의 메서드가 사용된다(오버라이딩된 메서드 → 중복정의 했으므로)
    - 중복정의되지 않은경우 타입에 따른 변화는 없다

---

- 매개변수의 다형성
    - 부모타입으로 자손타입의 객체를 가리킬 수 있다는 것은 매개변수를 부모타입으로 받겠다 선언하면 모든 자식타입의 인스턴스들을 매개변수로 받을 수 있다는 것을 의미한다

---

- 여러 종류의 객체를 배열로 다루기
    - 부모타입으로 자손타입의 객체를 가리킬수 있으므로 자식타입들의 객체를 부모타입배열로 같이 관리할 수 있다
    
    ```java
    Product[] p = new Product[10];  //부모타입 배열
    Product[0] = new Tv();  //Product클래스의 자식
    Product[1] = new Computer();  //Product클래스의 자식
    Product[2] = new Audio();  //Product클래스의 자식
    ```
    

---

- 추상클래스
    - 추상클래스는 미완성 설계도이다
    - 미완성 메서드(추상 메서드)를 가지고 있다는 의미이다
        - 추상 메서드란 메서드의 선언부만있고 구현부는 없는 메서드이다
        - abstract 반환타입 이름 (매개변수); 인 메서드는 추상 메서드
            - 메서드 구현부{} 대신 ;를 사용
    - 클래스 이름 앞에 abstract를 사용하여 추상클래스를 선언
    - 추상클래스는 추상 메서드를 가지고 있다는 점 외에는 일반클래스와 다르지 않다
        - 멤버변수, 메서드, 생성자를 가질 수 있다
    - 추상클래스는 미완성 설계도이므로 추상클래스의 인스턴스를 생성할 수 없다
        - 클래스로써의 역할을 다하지 못하지만 새로운 클래스를 작성하는데 있어 바탕이 되는 클래스로서 중요한 의미를 갖는다
    - 자식클래스가 추상클래스를 상속받아서 추상 메서드를 구현해주어야 완성되며 완성된 자식클래스는 인스턴스를 생성할 수 있다
        - 만약 여러개의 추상 메서드가 있는 추상클래스를 자식 클래스가 상속받았을 경우 모든 추상 메서드를 구현해 주어야한다
        - 자식클래스는 부모클래스의 모든 멤버를 상속받으므로 구현되지 않은 추상메서드가 자식메서드에 남아있어 자식클래스도 추상메서드로 간주된다
    - 추상 메서드
        - 추상 메서드는 선언부만 작성하고 구현부는 없는 메서드
        - 이와같이 구현을 안하는 이유는 상속받는 클래스들에 따라 구현 내용이 달라질 수 있기 때문이다
            - 따라서 자식클래스는 부모클래스의 추상 메서드를 자기에 맞게 구현해주어야 한다
            - 구현부는 있지만 내용이 비어있는 메서드를 자식클래스에서 오버라이딩해주는 방식이랑 차이점은 추상 메서드를 사용하면 자식 클래스에서 무조건 내용을 구현해 주어야만 자식 클래스의 인스턴스를 생성할 수 있기때문에 자식클래스에 맞는 구현을 강제할 수 있다
    - 추상클래스의 작성
        - 여러 클래스에 공통적으로 사용될 부분을 바로 클래스로 작성하기도 하고, 기존의 클래스의 공통적인 부분을 뽑아서 추상 클래스로 만들어 상속하도록 하는 경우도 있다
        - 상속이 부모클래스를 확장(구체화)하는것이라면 추상화는 자식클래스들의 공통부분을 뽑아내 부모클래스를 만드는 것
        - 자식클래스들의 공통부분을 뽑아내 추상클래스로 만들어 상속받게 하면 다형성의 법칙에 따라서 자식클래스들을 추상클래스타입의 배열로 다룰 수 있다
        - 추상클래스에 작성된 추상메서드도 추상클래스타입의 참조변수로 사용하는 것이 가능하다
            - 메서드는 참조변수의 타입에 관계없이 실제 인스턴스에 구현된 것이 호출
            - 추상클래스는 인스턴스를 생성할 수 없고 인스턴스가 생성된 자식클래스들은 모두 부모인 추상클래스의 추상 메서드를 구현했을것이기 때문에 가능

---

- 인터페이스
    - 인터페이스는 일종의 추상클래스이다
    - 구현된것은 아무것도 없고 밑그림만 그려져있는 설계도
        - 추상클래스와 비슷하게 다른 클래스를 작성하는데 도움을 주는 목적
    - 추상클래스보다 추상화 정도가 높아서 멤버변수, 일반 메서드를 가질 수 없다
        - 상수, static메서드, default메서드를 가질 수 있다
    - 클래스를 작성하는것과 비슷하지만 키워드 class대신 interface를 사용한다
    - 인터페이스의 멤버상수는 항상 public static final이 붙는다(생략가능)
    - 인터페이스의 추상메서드는 항상 public abstrct가 붙는다(생략가능)
    - 인터페이스는 인터페이스에서만 상속을 받을 수 있으며 클래스와 달리 다중상속이 가능하다
    
    ```java
    interface Movable{
        public abstract void move(int x, int y);
    }
    interface Attackable{
        public abstract void attack(Unit u);
    }
    interface Fightable extends Movable, Attackable{} //인터페이스의 다중상속
    ```
    
    - 인터페이스를 구현하는 클래스는 구현하는 인터페이스의 모든 추상메서드를 구현해야하면 하나라도 구현하지 않으면 추상클래스가 된다
        - 상속과 달리 구현한다는 의미에서 implements키워드를 사용한다
        
        ```java
        interface Movable{
            public abstract void move(int x, int y);
        }
        interface Attackable{
            public abstract void attack(Unit u);
        }
        interface Fightable extends Movable, Attackable{}
        
        class Fighter implements Fightable {
            public void move(int x, int y){/*move메서드 구현*/}
            public void attack(Unit u){/*attack메서드 구현*/}
        }
        ```
        
    - 인터페이스를 구현하는 클래스는 인터페이스를 구현하는 동시에 다른 클래스를 상속받을 수도 있다
    
    ```java
    interface Movable{
        public abstract void move(int x, int y);
    }
    interface Attackable{
        public abstract void attack(Unit u);
    }
    interface Fightable extends Movable, Attackable{}
    
    class Fighter extends Unit implements Fightable {   //상속과 구현을 동시에
        public void move(int x, int y){/*move메서드 구현*/}
        public void attack(Unit u){/*attack메서드 구현*/}
    }
    ```
    
    - 인터페이스의 이름에는 주로 ~able로 주로 끝나는데 그 이유는 어떠한 기능 또는 행위를 하는데 필요한 메서드를 제공한다는 의미를 강조
    - 인터페이스를 구현한 클래스에서 인터페이스의 추상메서드를 구현하는 함수는 무조건 public이어야 한다
        - 오버라이딩하는 메서드는 조상의 접근제어자보다 좁은 범위의 접근제어자를 사용할 수 없는데 인터페이스의 추상메서드는 전부 public abstract메서드이기 때문이다
    - 인터페이스의 참조변수로 사용할 수 있는 메서드는 인터페이스에 선언된 메서드들 뿐이다

---

- 인터페이스를 이용한 다형성
    - 인터페이스 역시 인터페이스를 구현한 클래스의 인스턴스를 인터페이스타입의 참조변수로 참조하는것이 가능하며 형변환역시 가능하다
    - 같은 원리로 인터페이스타입의 매개변수도 받을 수 있으며 이는 인터페이스를 구현한 인스턴스를 매개변수로 받는다는 의미이다
    - 반환타입도 인터페이스타입으로 적을 수 있는데 이는 해당 메서드는 이 인터페이스를 구현한 인스턴스를 반환한다는 의미이다

---

- 인터페이스의 장점

![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A57%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%20e52fbe6d41f84bd7b93cef2d6a707a1a/Untitled%209.png)