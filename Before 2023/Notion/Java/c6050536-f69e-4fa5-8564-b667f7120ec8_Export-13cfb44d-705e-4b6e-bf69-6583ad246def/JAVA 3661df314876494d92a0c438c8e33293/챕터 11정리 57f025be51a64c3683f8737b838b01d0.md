# 챕터 11정리

---

- 컬렉션 프레임웍
    - 컬렉션 프레임웍이란 데이터 군을 저장하는 클래스들을 표준화한 설계
        - 컬렉션 → 다수의 데이터, 즉 데이터 그룹
        - 프레임웍 → 표준화된 프로그래밍 방식
    - 컬렉션 프레임웍에서는 컬렉션 데이터그룹을 크게 3가지 타입이 있다고 인식하고 각각의 타입을 다루는데 필요한 기능을 가진 3개의 인터페이스들을 정의하였다
        - List, Set, Map
        
        ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled.png)
        
        - List, Set 인터페이스는 공통된 부분을 뽑아내어 Collection이라는 인터페이스를 정의한다음 상속받게 하였다
        - Map인터페이스는 위의 두 인터페이스들과는 전혀 다른 형태로 컬렉션을 다루기때문에 Collection인터페이스를 상속받지 않는다
        - List
            - 순서가 있는 데이터들의 집합
            - 데이터의 중복을 허용
            - 구현 클래스 → ArrayList, LinkedList, Stack, Vector
        - Set
            - 순서를 유지하지 않는 데이터들의 집합
            - 데이터의 중복을 허용하지 않음
            - 구현 클래스 → HashSet, TreeSet
        - Map
            - 키(key)와 값(Value)의 쌍으로 이루어진 데이터의 집합
            - 순서는 유지하지 않으며 키의 중복을 허용하지 않고 값의 중복은 허용한다
            - 구현 클래스 → HashMap, TreeMap, HashTable, Properties
    - 컬렉션 프레임웍의 모든 컬렉션 클래스들은 위의 3가지 인터페이스중 하나를 구현하고 있으며, 구현한 인터페이스 이름을 클래스의 이름에 포함되므로 클래스의 특징을 잘 알수 있다
    - Vector, HashTable같은 컬렉션프레임웍이 나오기 전의 클래스들은 호환을 위해 설계가 변경되어 남겨져 있지만 가급적 ArrayList, HashMap을 사용하는게 좋다
    - Collection은 인터페이스이고 Collections는 클래스이다
        - 인터페이스에는 추상 메서드만 존재할 수 있다는 원칙을 지키기위해 분리해놨다

---

- Collection인터페이스
    - List와 Set인터페이스의 조상으로써 List와 Set인터페이스의 공통부분이 정의되어 있다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%201.png)
    
    - 반환타입이 boolean인 메서드들은 작업을 성공하면 true, 실패하면 false를 반환한다
    - Collection인터페이스는 컬렉션 클래스에 저장된 데이터를 읽고 추가하고, 삭제하는등 컬렉션을 다루는데 가장 기본적인 메서드들이 정의되어 있다

---

- List인터페이스
    - 중복을 허용하고 순서가 유지되는 컬렉션을 구현하는데 사용되는 인터페이스
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%202.png)
    

---

- Set인터페이스
    - 중복을 허용하지 않고 순서가 유지되지 않는 컬렉션을 구현하는데 사용되는 인터페이스
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%203.png)
    

---

- Map인터페이스
    - 키와 값을 하나의 쌍으로 묶어 저장하는 컬렉션을 구현하는데 사용되는 인터페이스
    - 키는 중복을 허용하지 않지만 값은 중복을 허용한다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%204.png)
    
    - keySet메서드는 반환값이 Set이다
        - Set인터페이스는 중복을 허용하지 않으므로 마찬가지로 중복을 허용하지 않는 키를 반환한다
    - values메서드는 반환값이 Collection이다
        - Collection인터페이스는 중복을 허용하므로 마찬가지로 중복을 허용하는 값(value)를 반환한다

---

- ArrayList
    - 배열과 비슷하게 동작
        - 내부적으로 Object배열을 사용하기 때문
    - 배열의 길이가 부족하면 자동으로 배열의 길이를 늘려서 저장해줌
        - 이때 새로운 배열을 생성해서 값을 복사하는것이기 때문에 비효율적임
        - 따라서 ArrayList를 생성할때는 요소의 개수를 고려해서 길이를 넉넉하게 잡아주는 것이 좋음
    - capacity가 부족할경우 자동으로 기존의 capacity보다 2배로 증가된다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%205.png)
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%206.png)
    
    - 만약 중간에 있는 요소를 삭제하면 뒤에있는 요소들이 빈자리를 채우기위해 앞으로 이동한다

---

- LinkedList
    - 배열(Array)는 가장 기본적인 형태의 자료구조로 구조가 간단하며 사용하기 쉽고 특정 인덱스의 데이터를 읽어오는데 걸리는 시간이 가장 빠르다
    - 하지만 배열은 크기가 정적이고 크기를 변경하려면 새로운 배열을 생성해서 요소들을 전부 복사하는 작업을 거쳐야하기 때문에 비효율적이다
    - 또한 배열은 순차적으로 마지막에 요소를 추가하거나 삭제하는것은 빠르지만 중간에 데이터를 추가하거나 삭제하는것은 마찬가지로 배열을 복사하는 작업을 거치므로 비효율적이다
    - 링크드리스트는 배열의 단점을 보완하기위해 만든 자료구조이다
    - 링크드리스트는 데이터뿐만아니라 다음 데이터의 주소값을 함께 저장함으로써 불연속적인 데이터들을 연결된것처럼 보이게한다
    - 링크드리스트에서 데이터의 삭제는 삭제할 요소의 주소값을 저장하고 있는 이전 데이터의 주소값을 삭제할 요소의 다음 주소값으로 변경하기만 하면 되므로 빠르다
    - 마찬가지로 데이터의 추가는 새로운 데이터의 주소를 삽입할 인덱스의 이전 데이터가 저장하고 새로운 데이터는 삽입할 인덱스의 다음 데이터의 주소값을 저장하면 되므로 빠르다
    - 하지만 링크드리스트는 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 빠르지만 이전 요소에 대한 접근은 어렵다
    - 따라서 링크드리스트에서 이전 요소의 주소값도 함께 저장하는 이중 링크드리스트를 자주 사용한다
        - 자바에서 LinkedList클래스는 이중 링크드리스트를 사용한다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%207.png)
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%208.png)
    
    - 일반적인 배열에서 n번째 요소의 주소값은 배열의 주소(참조변수의 값) + n * 데이터 타입 크기로 정해져 있기때문에 ArrayList같은 배열은 n번째 인덱스의 값을 읽어오는데 데이터의 주소값을 위의 수식에 대입해서 바로 가져올 수 있으므로 접근이 빠르다
    - 하지만 링크드리스트는 불연속적이므로 n번째 데이터를 읽어오는데 첫번째 요소부터 순차적으로 n번 참조해야한다

---

- Stack
    - LIFO(Last In First Out)구조
        - 나중에 들어온것이 맨 처음 나간다
    - 스택의 구조상 맨 뒤 요소의 삭제가 효율적인 ArrayList를 사용한다
    - 자바에서 스택은 Stack클래스로 구현하여 제공한다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%209.png)
    

---

- Queue
    - FIFO(First In First Out)구조
        - 먼저 들어온것이 먼저 나간다
    - 큐의 구조상 ArrayList로 만들면 맨 앞 요소의 삭제가 이루어질때마다 배열을 복사하는 작업이 필요하므로 데이터의 추가/삭제가 쉬운 LinkedList를 사용한다
    - 자바에서 큐는 Queue인터페이스로만 정의해 놓았을뿐 별도의 클래스를 제공하지 않는다
        - 따라서 Queue인터페이스의 구현체인 클래스들을 선택해서 사용한다
        - AbstractQueue, ArrayBlockingQueue, ArrayDeque, ConcurrentLinkedDeque, ConcurrentlinkedQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue,
        LinkedList, LinkedTransferQueue, PriorityBlockingQueue, PriorityQueue,
        SynchronousQueue
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%2011%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2057f025be51a64c3683f8737b838b01d0/Untitled%2010.png)
    

---

- PriorityQueue
    - Queue인터페이스의 구현체중 하나로 저장한 순서에 관계없이 우선순위가 높은것부터 차례로 꺼낸다
        - 우선순위를 내부적으로 저장할 수 없는경우(객체를 저장했을경우) 우선순위를 비교할 수 있는 방법을 제공해주어야 한다
    - null은 저장할 수 없다
        - null을 저장하면 NullPointerException이 발생

---

- Deque
    - Double-Ended Queue
        - 인터페이스이며 조상은 Queue이다
        - 끝이 두개인 큐
        - 맨 앞에서 삭제, 추가가 가능하고 맨 뒤에서도 삭제, 추가가 가능하다
    - 큐와 스택을 합쳐놓은것과 같다
    - 메서드
        - offerLast(뒤에 저장)
        - pollLast(뒤 삭제)
        - offerFirst(앞에 저장)
        - pollFirst(앞 삭제)