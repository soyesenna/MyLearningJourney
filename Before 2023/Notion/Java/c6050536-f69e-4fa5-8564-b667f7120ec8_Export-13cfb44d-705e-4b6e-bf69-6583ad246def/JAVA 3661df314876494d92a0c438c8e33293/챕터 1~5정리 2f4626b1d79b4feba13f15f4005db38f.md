# 챕터 1~5정리

### <챕터 1~5>

---

- 변수 명명규칙
1. 클래스 이름의 첫 글자는 항상 대문자로 한다.
2. 변수와 메서드의 이름 첫글자는 항상 소문자로 한다.
3. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.(lastIndexOf)
4. 상수의 이름은 모두 대문자로 한다.

---

- 변수 기본형

-boolean : 1byte →true or false

-char : 2byte → 문자

-int : 4byte → 정수(약 +-20억)

-short : 2byte → 정수

-long : 8byte → 정수

-byte : 1byte → 정수

-float : 4byte → 실수

-double : 8byte → 실수

---

- 상수

상수는 변수와 같이 값을 저장할 수 있지만 한번 초기화한 후에 값을 변경할수 없다.

final키워드를 붙여서 선언(final double PI = 3.14)

상수 이름은 보통 대문자로 선언

---

- 리터럴

보통 우리가 생각하는 상수.

int age = 23; ← 23이 리터럴

—리터럴의 타입과 접미사

-접미사의 종류

정수 → L(l)

실수 → f, d

나머지 기본형은 접미사 없음

정수에서는 int가 기본자료형, 실수는 double이 기본 자료형

따라서 접미사가 생략되어 있을 경우는 기본자료형이라고 생각함

변수의 타입과 리터럴의 타입이 대부분 일치하지만 아닌경우도 있음

-이때는 리터럴의 타입이 변수의 타입보다 표현범위가 크면 에러

---

- String의 덧셈

String은 기본적으로 클래스

String끼리의 덧셈이 아닌 다른 변수(기본형, 참조형)과의 연산은 String이 아닌 변수를 String으로 변환한 후 연산 → 7 + “7” == “77”, 7 + 7 + “7” == “147”

참조형과 연산하면 주소값이 String이 되는듯

---

Integer.toBinaryString(2); → “10”

Integer.parseInt(”9”) → 9(int)

Float.parseFloat(”3.14”) → 3.14(float)

---

- Scanner

사용자에게 화면에서 입력받기위한 클래스

java.util에 있음 → import java.util.*

```java
Scanner scanner = new Scanner(System.in); //Scanner객체 생성
System.out.print("월의 이름을 입력하시오:");
String month = scanner.nextLine(); //String으로 받음
scanner.close();
```

nextInt, nextFloat같은 메서드들도 있지만 연속적으로 값을 입력받아 사용하기 까다로움

nextLine을 사용하여 적절히 변환하는게 나음

---

- 캐스팅과 연산자

캐스팅은 변수나 리터럴의 타입을 변경하는 것을 말함 → int a; (long)a;

캐스팅을 명시적으로 해주지 않아도 값을 최대한 보존시킬수 있는 방향으로 자동으로 캐스팅이 진행됨

-byte → short, char → int → long → float → double

연산에서 리터럴의 타입을 명시하지 않으면 기본 자료형(int, double)로 간주하여 연산함

따라서 연산할때 연산이 되는 리터럴의 값의 크기와 타입, 연산결과를 저장할 변수의 타입을 고려해야함

-byte b = 100 + 200; → error(100, 200은 기본적으로 int이므로 100+200의 결과는 300(int)임. 따라서 연산결과의 타입인 int에서 byte로 변환할때 값 손실이 일어남)

— byte b = (byte)100 + 200;으로 바꿔줘야함

-long l = 1_000_000_000 * 2_000_000_000; → error(1000000,2000000은 int리터럴이므로 연산 결과도 int형으로 반환됨. 따라서 int형의 크기를 넘어가는 결과가 나오면 오버플로우가 발생한다)

-long l = 1_000_000_000 * 2_000_000_000L; || (long)1_000_000_000 * 2_000_000_000;

으로 바꿔줘야함

---

리터럴간의 연산은 컴파일 시에 컴파일러가 계산해서 그 결과로 대체함

-char c = ‘a’ + 1; → char c = ‘b’;

하지만 수식에 변수가 들어있으면 미리 계산을 할 수 없음

```java
char c1 = 'a';
char c2 = c1 + 1; //error c1 + 1의 결과가 int기 때문
char c2 = (char)(c1 + 1); //OK
```

---

- 문자열 비교

String의 내용을 비교할때는 equals()메소드를 이용해야함

String은 기본적으로 객체이므로 String끼리 ==연산자는 주소를 비교하여 값을 반환한다

```java
String str = "abc";
String str2 = "abc";
boolean eq = str.equals(str2);
System.out.println(eq); //true
```

equalsIgnoreCase() → 대소문자를 구별하지않고 비교

---

- Math.random() → 0.0 ≤ Math.random() < 1.0범위의 값을 double형으로 반환
- String.charAt(index) → String에서 index번호의 char을 반환

```java
String str = "abc";
char ch = str.charAt(2);
System.out.println(ch); //'c'출력
```

- String.toCharArray(); → String을 char array로 반환

---

- 향상된 for문
    
    -JDK1.5부터 배열과 컬렉션에 저장된 요소에 접근할때 사용할 수 있는 문법
    
    -for(타입 변수명 : 배열 또는 컬렉션){}
    
    ```java
    int[] arr = {1,2,3,4,5};
    for(int tmp : arr){
        System.out.println(tmp);
    }
    /*
    1
    2
    3
    4
    5
    */
    ```
    

---

- 이름 붙은 반복문
    
    -중첩 반복문에서 break, continue문을 사용할때 중첩 반복문 앞에 이름을 붙이고 break, continue문에 이름을 지정해 줌으로써 하나 이상의 반복문을 벗어나거나 건너뛸 수 있다
    

```java
Loop1 : for(int i = 0; i < 5; i++){
            for(int j = 0; j < 5; j++){
                if(j == 3) break Loop1;
                System.out.println("" + i + j);
            }
        }
/*
00
01
02
*/
```

---

- 배열의 길이
    
    -배열의 길이는 배열이름.length라는 이름으로 저장되어있다.
    
    ```java
    int[] arr = new int[10];
    	System.out.println(arr.length);//10
    ```
    
    -배열의 길이는 상수이므로 변경이 불가능하다.
    

---

- 배열의 복사
    
    -for문을 이용한 방법.
    
    -기존 배열보다 길이가 두배인 배열을 새로 만들고 for문으로 기존배열의 각각의 값에 접근하여
    
    새로운 배열에 저장.
    
    ```java
    int[] arr = new int[10];
    int[] tmp = new int[arr.length * 2];
    for(int i = 0; i < arr.length; i++){
        tmp[i] = arr[i];
    }
    arr = tmp;  //기존 arr배열이 tmp배열을 가리키도록 함.
    						// 참조변수가 없어진 기존 arr배열은 GC에의해 정리됨.
    
    ```
    
    -System.arraycopy()메서드를 사용하는 방법.
    
    -System.arraycopy()메서드는 for문으로 복사하는것보다 효율적으로 복사해줌
    
    -System.arraycopy(기존 배열, 복사를 시작할 기존배열의 인덱스, 새 배열, 복사를 받을 새 배열의 인덱스, 복사할 데이터의 개수)
    
    -System.arraycopy(num, 0, newNum, 0, num.length); → num[0]에서 newNum[0]으로 num.length개의 데이터를 복사
    
    ```java
    char[] abc = new char[]{'A','B','C','D'};
    char[] num = new char[]{'1','2','3','4','5','6','7','8','9'};
    
    System.out.println(abc);    //ABCD
    System.out.println(num);    //123456789
    
    //abc배열과 num배열을 이어서 하나의 배열로 만듬
    char[] result = new char[abc.length + num.length];
    System.arraycopy(abc, 0, result, 0, abc.length);
    System.arraycopy(num, 0, result, abc.length, num.length);
    System.out.println(result); //ABCD123456789
    
    //abc배열을 num배열의 첫 번째 위치부터 복사
    System.arraycopy(abc, 0, num, 0, abc.length);
    System.out.println(num);    //ABCD456789
    
    //num의 인덱스6위치에 3개만큼 복사
    System.arraycopy(abc, 0, num, 6, 3);
    System.out.println(num);    //ABCD45ABC9
    ```
    

---

- 2차원배열에서의 향상된 for문
    - 2차원배열의 구조
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%201~5%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%202f4626b1d79b4feba13f15f4005db38f/Untitled.png)
    
    ```java
    int[][] arr = new int[3][4];
    
    int num = 0;
    //arr.length를 이용하여 배열에 접근하는 방법
    for (int i = 0; i < arr.length; i++) {  
        for (int j = 0; j < arr[i].length; j++) {
            arr[i][j] = num;
            num++;
        }
    }
    
    for(int[] tmp : arr){   //tmp는 1차원 배열의 주소를 가지는 참조변수
        for(int i : tmp){
            System.out.print(i + " ");
        }
        System.out.println();        
    }
    ```