# 챕터 6정리

---

- 클래스와 객체란?
    - 클래스 : 객체를 정의해놓은 설계도
    - 객체 : 클래스를 토대로 생성되는 제품
        - 객체는 속성(멤버 변수)과 기능(멤버 메서드)의 집합
        - Instance Variable의 집합
    - 객체에는 사물뿐만아니라 개념이나 논리와 같은 무형적인 것들도 포함
    - 객체지향개념을 사용하는 이유는 코드의 재사용성과 유지보수가 용이하고 중복된코드를 제거할 수 있다는 장점이 있어서 사용
    - 클래스는 설계도이므로 클래스를 통해 객체를 생성해야 사용할 수 있음
        - 클래스를 토대로 객체를 만드는 것을 클래스의 인스턴스화라고함

---

- 인스턴스의 생성과 사용
    - 클래스는 설계도일 뿐이므로 객체(인스턴스)를 생성해야 우리가 사용할 수 있음
    
    ```java
    	Tv t = new Tv();//Tv클래스의 참조변수 t를 생성하여 Tv객체의 주소를 저장
    ```
    
    - 인스턴스를 생성하기 위해서는 인스턴스의 주소를 저장할 참조변수가 필요함
        - 참조변수의 타입은 클래스 이름과 같아야함
        - 객체는 참조변수를 통해서만 접근할 수 있으며 객체를 가리키는 참조변수가 없으면 가비지컬렉터에의해 객체가 메모리에서 사라짐

---

- 객체 배열
    - 많은 수의 객체를 다룰 때 배열로 다룰 수 있음
        - 객체의 타입(클래스 이름)이 같아야함
        - 객체 배열안에 객체가 생성되는 것이 아니고 객체배열은 참조변수들의 배열임
            - 객체 참조변수들의 배열이 생성되고 객체배열의 각각의 요소들이 각각의 객체를 가리키는것
        
        ```java
        Tv[] t = new Tv[3]; //Tv클래스 참조변수 배열 생성
        
        //배열의 각각의 참조변수들에 Tv객체 할당
        t[0] = new Tv();
        t[1] = new Tv();
        t[2] = new Tv();
        ```
        

---

- 클래스의 또 다른 정의
1. 데이터와 함수의 결합
    1. 서로 관련이 있는 데이터와 함수를 묶어놓은 것
    2. 함수는 주로 데이터를 통해 작업하기 때문에 함수와 데이터는 관계가 깊음
    3. 관계가 깊은 변수와 데이터를 같이 정의하여 다루면 작업이 명료해지고 유기적으로 변함
2. 사용자 정의 타입
    1. 자바에서 제공하는 기본형 타입뿐만 아니라 관련이 돼있는 여러가지 타입들을 하나로 묶어서 하나의 타입으로 정의할 수 있음
    
    ```java
    //시간과 관련된 변수를 묶어서 Time클래스 정의
    Time t = new Time();
    t.hour = 1;
    t.minitue = 23;
    t.second = 50;
    ```
    

---

- 선언위치에 따른 변수의 종류
    - 변수는 클래스변수, 인스턴스변수, 지역변수로 나뉨
        1. 인스턴스 변수
            1. 클래스 영역에 선언되며 인스턴스가 생성될때 만들어짐
            2. 인스턴스 변수의 값을 읽거나 저장하기 위해서는 인스턴스를 먼저 생성해야함
            3. 같은 이름이라도 각각의 인스턴스마다 저장된 위치가 다르므로 각각의 인스턴스마다 고유한 값을 가짐
            4. 인스턴스가 소멸하면 같이 소멸
        2. 클래스 변수
            1. 클래스영역에 선언되며 인스턴수 변수 선언문 앞에 static을 붙이면 됨
            2. 클래스 변수는 모든 인스턴스가 값을 공유함
            3. 인스턴스의 공간에 저장되는 것이 아닌 고유한 공간에 저장됨
            4. 따라서 인스턴스를 생성하지 않고도 바로 사용가능
                1. 클래스이름.클래스변수 형식으로 사용
            5. 클래스가 메모리에 로딩될때 생성되어 프로그램이 종료될때 까지 유지
        3. 지역 변수
            1. 메서드 내에서 선언되어 메서드가 종료되면 사라짐
            2. for, while과 같은 블럭에서 선언된 변수들은 블럭이 끝나면 사라짐
        
        ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%206%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2028d318b55f8a47ff88e9ed23a38aba54/Untitled.png)
        

---

- JVM메모리 구조
    - JVM의 메모리구조는 메서드영역, 힙, 호풀스택으로 이루어져있다
        1. 메서드영역
            1. 클래스에 대한 정보(클래스 데이터)를 저장하는곳.
            2. cv가 여기에 저장됨
        2. 힙
            1. 인스턴스가 생성되는 공간.
            2. 인스턴스 변수가 이곳에 저장됨
        3. 호출스택
            1. 메서드 작업에 필요한 메모리 공간을 제공
            2. 메서드가 호출되면 메서드작업에 필요한 공간을 할당하는곳
            3. 매개변수, 지역변수등이 저장
            4. 메서드가 끝나면 반환되어 사라짐

---

- new연산자
    - new연산자는 객체를 heaq영역에 메모리 공간을 할당해주고 주소를 반환해 준다음 생성자를 실행시켜 준다
    - 리터럴과 달리 같은 값을 가진 객체가 있어도 다른 공간을 할당해준다

---

- 클래스 메서드와 인스턴스 메서드
    - 클래스는 서로 밀접한 관련이 있는 변수와 메서드들을 모아놓은 것
    - 인스턴스 메서드는 클래스내의 인스턴스 변수들을 사용하여 작업하는 메서드를 의미
        - 인스턴스 변수는 객체가 생성되어야만 생성되므로 인스턴스 메서드도 객체가 생성되어야만 호출이 가능함
    - 클래스 메서드는 인스턴스 변수를 사용하지 않는 메서드를 의미
        - 인스턴스 변수를 사용하지 않으므로 객체가 생성되지 않아도 호출 가능
        - 클래스이름.클래스메서드 이름으로 호출 가능
        - 클래스 변수(cv)는 객체생성과 관련없이 사용이 가능하므로 클래스 메서드에서도 사용 가능
        - 메서드 선언 앞에 static을 붙여서 선언
        - 인스턴스 변수사용, 인스턴스 메서드 호출 둘다 불가능
            - 인스턴스 메서드 또한 인스턴스 변수를 사용할 가능성이 있기 때문
        
        ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%206%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2028d318b55f8a47ff88e9ed23a38aba54/Untitled%201.png)
        

---

- 인스턴스 메서드와 클래스 메서드의 호출
    - 인스턴스 메서드는 객체를 생성해야만 사용할 수 있는 메서드임
    - 따라서 객체 생성 없이 호출 할 수 있는 클래스 메서드에서는 호출이 불가능
    - 인스턴스 메서드끼리는 별도의 참조 없이 호출이 가능
        - 하나의 인스턴스 메서드가 존재한다는 것은 다른 인스턴스 메서드도 존재한다는 의미
    - 마찬가지 이유로 클래스메서드에서는 인스턴스 변수도 사용 불가능

---

- 오버로딩
    - 오버로딩은 하나의 클래스내에 같은 이름의 메서드를 여러개 정의하는것을 의미함
    - 같은 이름의 함수를 컴파일러가 구분할때는 매개변수의 타입이나 개수로 구분하기 때문에 오버로딩을 할때는 매개변수의 타입이나 개수를 다르게 해야함
    - 반환타입은 오버로딩에 영항을 주지 않음
    - 같은 기능을 하는 메서드인데 받는 매개변수가 다른 경우 오버로딩이 없으면 메서드 이름으로 구별해야해서 불편함
        - 오버로딩으로 해결 가능

---

- 가변인자
    - 매개변수개수를 동적으로 지정할 수 있게 해주는 기능
    - 타입… 변수명 형식으로 선언
    
    ```java
    public static void main(String[] args) {
            System.out.println(concatenate());  //인자 0개 
            System.out.println(concatenate("a"));   //인자 1개
            System.out.println(concatenate("a", "b"));  //인자 2개
            System.out.println(concatenate(new String[]{"A", "B"}));    //배열도 가능
        }
    
        static String concatenate(String... str){   //가변인자로 선언
            String result = "";
            for(String tmp : str){  //가변인자는 내부적으로 배열을 이용
                result += tmp;
            }
            return result;
        }
    ```
    
    - 가변인자는 내부적으로 배열을 이용하는것
        - 가변인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성됨

---

- 생성자
    - 생성자는 인스턴스가 생성될때 호출되는 메서드
    - 인스턴수 변수들을 초기화하는 역할을 함
    - 생성자의 이름은 클래스 이름과 같아야하며 반환값을 적어주지 않는다
    - 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다
    
    ![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%206%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2028d318b55f8a47ff88e9ed23a38aba54/Untitled%202.png)
    

---

- 기본생성자
    - 가장 기본적인 생성자로 매개변수와 메서드 내용이 없는 생성자임
    - 만약 클래스내에 생성자가 하나도 없으면 컴파일러가 자동으로 기본생성자를 추가해줌
    - 항상 클래스를 만들때 기본 생성자는 만들어줘야함

---

- 매개변수가 있는 생성자
    - 생성자도 매서드이므로 매개변수를 받아서 인스턴스 초기화 작업에 사용할 수 있다
    
    ```java
    public static void main(String[] args) {
            Time t1 = new Time(12, 34, 56.0);
        }
    
    }
    
    class Time{
        int hour;
        int minitue;
        double second;
    
        Time(){};   //기본생성자
        Time(int h, int m, double s){
            hour = h;
            minitue = m;
            second = s;
        }
    }
    ```
    

---

- 생성자 this()
    - 생성자에서 같은 클래스내의 다른 생성자를 호출할때 사용
    - 생성자에서 다른 생성자를 호출할때는 반드시 this()를 사용해야함
    - this()는 생성자(메서드) 가장 첫줄에 호출해야함
        - 호출한 생성자도 인스턴스변수를 초기화하는 역할을하므로 this()로 호출하기 전에 했던 초기화 작업들이 덮어씌워질 가능성이 있음

---

- 참조변수 this
    - 참조변수 this는 인스턴스 자신의 주소를 담고있는 참조변수
    - 모든 인스턴스메서드에 지역변수로 숨겨진채로 존재함
    - static메서드는 사용할 수 없음
    - this.color = color; → this.color는 인스턴스 변수고 color는 지역변수임

![Untitled](%E1%84%8E%E1%85%A2%E1%86%B8%E1%84%90%E1%85%A5%206%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%85%E1%85%B5%2028d318b55f8a47ff88e9ed23a38aba54/Untitled%203.png)

---

- 변수의 초기화
    - 멤버변수는 초기화하지 않아도 기본값으로 초기화 되지만 지역변수는 사용하기전에 반드시 초기화해야한다
    - 멤버변수 변수의 초기화 방법은 명시적초기화, 초기화 블럭, 생성자로 나뉜다
        1. 명시적 초기화
            1. 명시적 초기화는 대입연산자(=)를 사용하여 초기화 하는 방법이다
            2. 변수 선언부에 int num = 1; 과같이 초기화한다
        2. 초기화 블럭
            1. 초기화 블럭은 {} 블럭을 사용하여 초기화 하는 방법이다
            2. 명시적 초기화에서는 불가능한 여러 문장들을 수행하여 초기화를 해야할때 사용한다
            3. 클래스 변수를 초기화 할때는 static{}; 를 사용하여 초기화한다
        3. 생성자
            1. 생략…
    - 초기화 순서는 명시적 초기화 → 초기화 블럭 → 생성자 순이다